"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MultiplaneCanvas = function () {
    var MultiplaneCanvas = function () {
        function MultiplaneCanvas() {
            var _this = this;

            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _classCallCheck(this, MultiplaneCanvas);

            var FPS = args.fps || 60;
            var canvas = args.canvas || document.querySelector("canvas");
            var context = canvas.getContext("2d");

            this.waitForAssets = args.waitForAssets || true;
            this.scene = new Scene(canvas.width, canvas.height, context, this.waitForAssets);
            this.reactOnScroll = args.reactOnScroll || false;
            this.reactOnMouse = args.reactOnMouse || false;
            this.onRender = args.onRender || function () {};

            var scene = this.scene;
            var camera = this.scene.camera;

            var onMouseOver = function onMouseOver(e) {
                if (_this.reactOnMouse) {
                    var x = -(e.clientX - canvas.clientWidth / 2) * 0.15;
                    var y = -(e.clientY - canvas.clientHeight / 2) * 0.2;
                    camera.adjust(x, y);
                }
            };
            canvas.addEventListener("mousemove", onMouseOver.bind(this));

            var onScroll = function onScroll(e) {
                if (_this.reactOnScroll) {
                    camera.adjust(0, -window.scrollY / 2);
                }
            };
            window.addEventListener("scroll", onScroll.bind(this));

            var interval = 1000 / FPS;
            var last_tick = performance.now();
            var delta = void 0;

            var emitEvent = this;

            function render(tick) {
                context.clearRect(0, 0, canvas.width, canvas.height);
                scene.render();
                emitEvent.onRender(tick);
            }

            function animate(tick) {
                requestAnimationFrame(animate.bind(this));

                delta = tick - last_tick;
                if (delta > interval) {
                    scene.setAxis(canvas.width, canvas.height);
                    render(tick);
                    last_tick = tick - delta % interval;
                }
            }
            animate();
        }

        _createClass(MultiplaneCanvas, null, [{
            key: "Camera",
            get: function get() {
                return Camera;
            }
        }, {
            key: "ImagePlane",
            get: function get() {
                return ImagePlane;
            }
        }, {
            key: "Vector",
            get: function get() {
                return Vector;
            }
        }]);

        return MultiplaneCanvas;
    }();

    var Scene = function () {
        function Scene(w, h) {
            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var cache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            _classCallCheck(this, Scene);

            this.camera = new Camera();
            this.context = context;
            this.canvas = this.context.canvas;
            this.cacheScene = cache;
            this.planes = [];

            this.setAxis(w, h);

            this.cached = false;
        }

        _createClass(Scene, [{
            key: "render",
            value: function render() {
                if (this.cached || !this.cacheScene) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {

                        for (var _iterator = this.planes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var obj = _step.value;


                            this.context.globalAlpha = obj.alpha;

                            var x = this.axis.x + obj.position.x + this.camera.getPosition().x * obj.position.z;
                            var y = this.axis.y + obj.position.y + this.camera.getPosition().y * obj.position.z;

                            switch (obj.type) {
                                case "ImagePlane":
                                    this.context.drawImage(obj.image, x, y, obj.width, obj.height);
                                    break;
                                default:
                                    this.context.fillStyle = obj.color;
                                    this.context.fillRect(x, y, obj.width, obj.height);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    this.camera.update();
                } else {
                    this.isCached();
                }
            }
        }, {
            key: "isCached",
            value: function isCached() {
                var results = false;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.planes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var obj = _step2.value;

                        if (!obj.cached) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                this.cached = true;
                return results;
            }
        }, {
            key: "add",
            value: function add(obj) {
                this.planes.push(obj);
            }
        }, {
            key: "loadFromJson",
            value: function loadFromJson(jsonScene) {
                var objects = jsonScene.objects;
                var camera = jsonScene.camera;
                if (camera) {
                    this.camera.setPosition(camera.x, camera.y);
                }
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = objects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var obj = _step3.value;

                        var pos = obj.position;
                        var imagePlane = new ImagePlane(pos.x, pos.y, pos.z, obj.scale, obj.image, obj.alpha);
                        this.add(imagePlane);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
        }, {
            key: "setAxis",
            value: function setAxis(w, h) {
                this.axis = new Vector(w / 2, h / 2, 0);
            }
        }]);

        return Scene;
    }();

    var Camera = function () {
        function Camera(x, y, z) {
            _classCallCheck(this, Camera);

            this.position = new Vector(x || 0, y || 0, z || 0);
            this.force = new Vector(0, 0, 0);

            this.nextPosition = new Vector(0, 0, 0);
            this.lastPosition = new Vector(0, 0, 0);
        }

        _createClass(Camera, [{
            key: "update",
            value: function update() {

                var distX = this.nextPosition.x - this.lastPosition.x;
                var distY = this.nextPosition.y - this.lastPosition.y;

                this.position.x += (distX + this.force.x) / 24;
                this.position.y += (distY + this.force.y) / 24;
            }
        }, {
            key: "move",
            value: function move(x, y, z) {
                x = x || 0;
                y = y || 0;
                var nextPos = new Vector(x, y, z);
                this.lastPosition = this.position;
                this.nextPosition = nextPos;
            }
        }, {
            key: "adjust",
            value: function adjust(x, y, z) {
                this.force.x = x;
                this.force.y = y;
                this.force.z = z;
            }
        }, {
            key: "getPosition",
            value: function getPosition() {
                return new Vector(this.position.x, this.position.y);
            }
        }, {
            key: "setPosition",
            value: function setPosition(x, y) {
                this.position.x = x;
                this.position.y = y;
            }
        }]);

        return Camera;
    }();

    var ImagePlane = function ImagePlane(x, y, z, scale, img) {
        var _this2 = this;

        var alpha = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

        _classCallCheck(this, ImagePlane);

        this.type = "ImagePlane";

        this.position = new Vector(0, 0, 0);

        this.color = "green";
        this.alpha = alpha;

        this.image = new Image();
        this.image.src = img;

        this.cached = false;

        this.image.onload = function () {

            z = z / 100;

            _this2.scale = scale;
            var aspect_ratio = _this2.image.width / _this2.image.height;

            _this2.width = _this2.scale * z;
            _this2.height = _this2.scale * z / aspect_ratio;

            _this2.position.x = x - _this2.width / 2;
            _this2.position.y = y - _this2.height / 2;
            _this2.position.z = z;

            _this2.cached = true;
        };
    };

    var Vector = function Vector(x, y, z) {
        _classCallCheck(this, Vector);

        this.x = x;
        this.y = y;
        this.z = z;
    };

    return MultiplaneCanvas;
}();
